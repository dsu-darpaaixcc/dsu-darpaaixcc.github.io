{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CRS Homepage Team Other","title":"CRS Homepage"},{"location":"#crs-homepage","text":"","title":"CRS Homepage"},{"location":"#team","text":"","title":"Team"},{"location":"#other","text":"","title":"Other"},{"location":"Technical-Docs/outline/","text":"General Overview These docs are for technical stuff, so design choices, etc blah blah Design Goals & Key Elements Modularity: Class based design \"drop in\" component replacement CRS Overview Resources Relevant resources for these docs: CRS Repo CRS init code (main.py) API Code (Api.py) Webserver Code (Does not exist yet) System Startup/Init The CRS is started upon the call of main.py. Once called, a few things happen in the following order: The logging singleton is initalized The API webserver is started The Webserver is started If this completes successfully, then the CRS is up!","title":"General"},{"location":"Technical-Docs/outline/#general","text":"","title":"General"},{"location":"Technical-Docs/outline/#overview","text":"These docs are for technical stuff, so design choices, etc blah blah","title":"Overview"},{"location":"Technical-Docs/outline/#design-goals-key-elements","text":"Modularity: Class based design \"drop in\" component replacement","title":"Design Goals &amp; Key Elements"},{"location":"Technical-Docs/outline/#crs-overview","text":"","title":"CRS Overview"},{"location":"Technical-Docs/outline/#resources","text":"Relevant resources for these docs: CRS Repo CRS init code (main.py) API Code (Api.py) Webserver Code (Does not exist yet)","title":"Resources"},{"location":"Technical-Docs/outline/#system-startupinit","text":"The CRS is started upon the call of main.py. Once called, a few things happen in the following order: The logging singleton is initalized The API webserver is started The Webserver is started If this completes successfully, then the CRS is up!","title":"System Startup/Init"},{"location":"Technical-Docs/AI%20%26%20ML/outline/","text":"(delete this line) use this for a starting outline for your docs Name/Title Overview else","title":"Outline"},{"location":"Technical-Docs/AI%20%26%20ML/outline/#nametitle","text":"","title":"Name/Title"},{"location":"Technical-Docs/AI%20%26%20ML/outline/#overview","text":"","title":"Overview"},{"location":"Technical-Docs/AI%20%26%20ML/outline/#else","text":"","title":"else"},{"location":"Technical-Docs/API/Endpoints/","text":"API Endpoints Documentation Overview This document outlines the available endpoints within the API, including details on request parameters, request body formats, response codes, and response body formats. Predict House Price Endpoint : /api/model/pocmodel/predict HTTP Method : POST Description : Predicts the house price based on the input year. Request Parameters None. Request Body Content-Type : application/json Structure : { \"yearBuilt\": 1985 } Response Codes 200 OK : The request was successful, and the prediction is returned. 400 Bad Request : The input data is invalid or missing. 500 Internal Server Error : An unexpected error occurred processing the request. Response Body Content-Type : application/json Structure (on success): { \"data\": 250000, \"status\": \"Successful\" }","title":"API Endpoints Documentation"},{"location":"Technical-Docs/API/Endpoints/#api-endpoints-documentation","text":"","title":"API Endpoints Documentation"},{"location":"Technical-Docs/API/Endpoints/#overview","text":"This document outlines the available endpoints within the API, including details on request parameters, request body formats, response codes, and response body formats.","title":"Overview"},{"location":"Technical-Docs/API/Endpoints/#predict-house-price","text":"Endpoint : /api/model/pocmodel/predict HTTP Method : POST Description : Predicts the house price based on the input year.","title":"Predict House Price"},{"location":"Technical-Docs/API/Endpoints/#request-parameters","text":"None.","title":"Request Parameters"},{"location":"Technical-Docs/API/Endpoints/#request-body","text":"Content-Type : application/json Structure : { \"yearBuilt\": 1985 }","title":"Request Body"},{"location":"Technical-Docs/API/Endpoints/#response-codes","text":"200 OK : The request was successful, and the prediction is returned. 400 Bad Request : The input data is invalid or missing. 500 Internal Server Error : An unexpected error occurred processing the request.","title":"Response Codes"},{"location":"Technical-Docs/API/Endpoints/#response-body","text":"Content-Type : application/json Structure (on success): { \"data\": 250000, \"status\": \"Successful\" }","title":"Response Body"},{"location":"Technical-Docs/API/General/","text":"General Resources CRS Repo API Code Folder Key Components Plugins Plugin Docs (Short plugin summary)","title":"General"},{"location":"Technical-Docs/API/General/#general","text":"","title":"General"},{"location":"Technical-Docs/API/General/#resources","text":"CRS Repo API Code Folder","title":"Resources"},{"location":"Technical-Docs/API/General/#key-components","text":"","title":"Key Components"},{"location":"Technical-Docs/API/General/#plugins","text":"Plugin Docs (Short plugin summary)","title":"Plugins"},{"location":"Technical-Docs/API/Plugins/","text":"Plugins Plugins are pieces of code that plugin to the CRS (or any flask app really, please steal this design if you want for your own projects). In the case of the CRS, the plugins are primarily model based, meaning they exist to interact with specific models. Plugins are great for modularity, as you can work exclusively on your \"plugin\", and as long as a few items are met, have it literally \"plug in\" to the project. Additionally, if one breaks, no biggie as it just gets skipped while the rest load. Ex: C Plugin: interacts with a model tied to C May have the following endpoints: /api/model/c/detect-vulnerabilites /api/model/c/fix-vulnerabilites Plugin Loader Loads plugins from the Model folder. Each Subfolder contains a plugin, which is a template/framework class that gets loaded on the API startup. This function is currenly in the Api.py file, named load_plugins . It's a tad bit messy, with about 3 nested loops, and could use a rework, but functions as expected, so it's fine for now. In a nutshell, the loader does the following: Finds the plugin (or in this case, model ) directory Iterates over the folders in the directory in each folder, searches for a py file. Imports that Py file Pulls needed items from Py file & Info class (Class name, Plugin Name, Plugin Path, etc) Takes the Class of the plugin, initializes it, passes in the app (the flask app instance), and runs the main method. If the main method is setup correctly (see example below), it should register all of its routes with the flask app, and start. Plugin Code Template The following is a bare minumum of what a plugin should contain, and what it needs to successfully work: from Utils.Logger import LoggingSingleton ################################################ # Info class ################################################ '''Info class Fill in your info for the plugin here. This is defined near the top, so it's accessible by anything that may need it. ''' class Info: name = \"ExamplePlugin\" author = \"author_name\" endpoint = \"/api/model/endpoint\" classname = \"ClassName\" class ClassName(): def __init__(self, app): self.logger = LoggingSingleton.get_logger() self.app = app ################################################ # Main Stuff ################################################ # main function for the plugin, gets called by the plugin loader def main(self): ''' Main function/entry point for the plugin. Called when plugin is loaded ''' self.logger.debug(f\"Loading {Info.name}\") self._register_routes() ## Put all the routes here. def _register_routes(self): self.app.route(f'{Info.endpoint}', methods = [\"GET\"])(self.model_endpoint) self.app.route(f'{Info.endpoint}/predict', methods = [\"POST\"])(self.model_predict) # note, change/delete this method. Multiple methods accross the project with the same name & registered routes will cause issues def example_endpoint(self): ''' example endpoint ''' # do whatever you want here, call other funcs/classes, etc. Just make sure # it returns a value if it's mapped to an endpoint # Calculate last digit of pi # Find the meaning of life return jsonify({\"status\":f\"Plugin {Info.name} successfully started\"})","title":"Plugins"},{"location":"Technical-Docs/API/Plugins/#plugins","text":"Plugins are pieces of code that plugin to the CRS (or any flask app really, please steal this design if you want for your own projects). In the case of the CRS, the plugins are primarily model based, meaning they exist to interact with specific models. Plugins are great for modularity, as you can work exclusively on your \"plugin\", and as long as a few items are met, have it literally \"plug in\" to the project. Additionally, if one breaks, no biggie as it just gets skipped while the rest load. Ex: C Plugin: interacts with a model tied to C May have the following endpoints: /api/model/c/detect-vulnerabilites /api/model/c/fix-vulnerabilites","title":"Plugins"},{"location":"Technical-Docs/API/Plugins/#plugin-loader","text":"Loads plugins from the Model folder. Each Subfolder contains a plugin, which is a template/framework class that gets loaded on the API startup. This function is currenly in the Api.py file, named load_plugins . It's a tad bit messy, with about 3 nested loops, and could use a rework, but functions as expected, so it's fine for now. In a nutshell, the loader does the following: Finds the plugin (or in this case, model ) directory Iterates over the folders in the directory in each folder, searches for a py file. Imports that Py file Pulls needed items from Py file & Info class (Class name, Plugin Name, Plugin Path, etc) Takes the Class of the plugin, initializes it, passes in the app (the flask app instance), and runs the main method. If the main method is setup correctly (see example below), it should register all of its routes with the flask app, and start.","title":"Plugin Loader"},{"location":"Technical-Docs/API/Plugins/#plugin-code-template","text":"The following is a bare minumum of what a plugin should contain, and what it needs to successfully work: from Utils.Logger import LoggingSingleton ################################################ # Info class ################################################ '''Info class Fill in your info for the plugin here. This is defined near the top, so it's accessible by anything that may need it. ''' class Info: name = \"ExamplePlugin\" author = \"author_name\" endpoint = \"/api/model/endpoint\" classname = \"ClassName\" class ClassName(): def __init__(self, app): self.logger = LoggingSingleton.get_logger() self.app = app ################################################ # Main Stuff ################################################ # main function for the plugin, gets called by the plugin loader def main(self): ''' Main function/entry point for the plugin. Called when plugin is loaded ''' self.logger.debug(f\"Loading {Info.name}\") self._register_routes() ## Put all the routes here. def _register_routes(self): self.app.route(f'{Info.endpoint}', methods = [\"GET\"])(self.model_endpoint) self.app.route(f'{Info.endpoint}/predict', methods = [\"POST\"])(self.model_predict) # note, change/delete this method. Multiple methods accross the project with the same name & registered routes will cause issues def example_endpoint(self): ''' example endpoint ''' # do whatever you want here, call other funcs/classes, etc. Just make sure # it returns a value if it's mapped to an endpoint # Calculate last digit of pi # Find the meaning of life return jsonify({\"status\":f\"Plugin {Info.name} successfully started\"})","title":"Plugin Code Template"},{"location":"Technical-Docs/Utils/Logging/","text":"Logging Arguably the MOST IMPORTANT part of this project, logging. Overview Logging in the CRS is done with Python's logging library, and a singleton. Why the singleton? Cause it makes life easier. Using the logger: Using the logger is easy : Setup: Class Based (preferred): Import the logger: from Utils.Logger import LoggingSingleton Set up the logger in your __init__ class: MyClass: def __init__(self): # please name it self.logger for consistency. self.logger = LoggingSingleton.get_logger() Setup: Not using classes (for whatever reason): Import the logger: from Utils.Logger import LoggingSingleton Set a variable as the logger logger = LoggingSingleton.get_logger() Calling the logger/logging things There are 5 main logger levels: DEBUG: Intended for detailed diagnostic information, useful for diagnosing problems but not relevant during normal operations. INFO: Used for routine information that confirms the program is working as expected, such as startup confirmations. WARNING: Indicates a potential problem that should be paid attention to, but the application can still function. ERROR: Reports a problem that has caused a failure in a specific part of the application, but it doesn't affect the overall program operation. CRITICAL: Signals a severe issue where the program cannot continue running, requiring immediate attention. Please exit() on criticals. To call each of these: self.logger.debug(\"YourTextHere\") self.logger.info(\"YourTextHere\") self.logger.warning(\"YourTextHere\") self.logger.error(\"YourTextHere\") self.logger.critical(\"YourTextHere\") Every logger call will print the parent class (if applicable) and the calling function, and log it to a file (CRS.log), so you just need to supply the text you want to say, and it's good to go:","title":"Logging"},{"location":"Technical-Docs/Utils/Logging/#logging","text":"Arguably the MOST IMPORTANT part of this project, logging.","title":"Logging"},{"location":"Technical-Docs/Utils/Logging/#overview","text":"Logging in the CRS is done with Python's logging library, and a singleton. Why the singleton? Cause it makes life easier.","title":"Overview"},{"location":"Technical-Docs/Utils/Logging/#using-the-logger","text":"Using the logger is easy :","title":"Using the logger:"},{"location":"Technical-Docs/Utils/Logging/#setup-class-based-preferred","text":"Import the logger: from Utils.Logger import LoggingSingleton Set up the logger in your __init__ class: MyClass: def __init__(self): # please name it self.logger for consistency. self.logger = LoggingSingleton.get_logger()","title":"Setup: Class Based (preferred):"},{"location":"Technical-Docs/Utils/Logging/#setup-not-using-classes-for-whatever-reason","text":"Import the logger: from Utils.Logger import LoggingSingleton Set a variable as the logger logger = LoggingSingleton.get_logger()","title":"Setup: Not using classes (for whatever reason):"},{"location":"Technical-Docs/Utils/Logging/#calling-the-loggerlogging-things","text":"There are 5 main logger levels: DEBUG: Intended for detailed diagnostic information, useful for diagnosing problems but not relevant during normal operations. INFO: Used for routine information that confirms the program is working as expected, such as startup confirmations. WARNING: Indicates a potential problem that should be paid attention to, but the application can still function. ERROR: Reports a problem that has caused a failure in a specific part of the application, but it doesn't affect the overall program operation. CRITICAL: Signals a severe issue where the program cannot continue running, requiring immediate attention. Please exit() on criticals. To call each of these: self.logger.debug(\"YourTextHere\") self.logger.info(\"YourTextHere\") self.logger.warning(\"YourTextHere\") self.logger.error(\"YourTextHere\") self.logger.critical(\"YourTextHere\") Every logger call will print the parent class (if applicable) and the calling function, and log it to a file (CRS.log), so you just need to supply the text you want to say, and it's good to go:","title":"Calling the logger/logging things"},{"location":"Technical-Docs/Web/outline/","text":"(delete this line) use this for a starting outline for your docs Name/Title Overview else","title":"Outline"},{"location":"Technical-Docs/Web/outline/#nametitle","text":"","title":"Name/Title"},{"location":"Technical-Docs/Web/outline/#overview","text":"","title":"Overview"},{"location":"Technical-Docs/Web/outline/#else","text":"","title":"else"},{"location":"User%20Docs/Overview/","text":"Overview Web Interface blah blah offers web interface for easy human interaction. This uses the API on the backend blah blah API Tblah blah he core of the CRS, see link blah blah","title":"Overview"},{"location":"User%20Docs/Overview/#overview","text":"","title":"Overview"},{"location":"User%20Docs/Overview/#web-interface","text":"blah blah offers web interface for easy human interaction. This uses the API on the backend blah blah","title":"Web Interface"},{"location":"User%20Docs/Overview/#api","text":"Tblah blah he core of the CRS, see link blah blah","title":"API"},{"location":"User%20Docs/API/Endpoints/","text":"API Endpoints Documentation Overview This document outlines the available endpoints within the API, including details on request parameters, request body formats, response codes, and response body formats. Predict House Price Endpoint : /api/model/predict HTTP Method : POST Description : Predicts the house price based on the input year. Request Parameters None. Request Body Content-Type : application/json Structure : { \"yearBuilt\": 1985 } Response Codes 200 OK : The request was successful, and the prediction is returned. 400 Bad Request : The input data is invalid or missing. 500 Internal Server Error : An unexpected error occurred processing the request. Response Body Content-Type : application/json Structure (on success): { \"predictedPrice\": 250000 }","title":"API Endpoints Documentation"},{"location":"User%20Docs/API/Endpoints/#api-endpoints-documentation","text":"","title":"API Endpoints Documentation"},{"location":"User%20Docs/API/Endpoints/#overview","text":"This document outlines the available endpoints within the API, including details on request parameters, request body formats, response codes, and response body formats.","title":"Overview"},{"location":"User%20Docs/API/Endpoints/#predict-house-price","text":"Endpoint : /api/model/predict HTTP Method : POST Description : Predicts the house price based on the input year.","title":"Predict House Price"},{"location":"User%20Docs/API/Endpoints/#request-parameters","text":"None.","title":"Request Parameters"},{"location":"User%20Docs/API/Endpoints/#request-body","text":"Content-Type : application/json Structure : { \"yearBuilt\": 1985 }","title":"Request Body"},{"location":"User%20Docs/API/Endpoints/#response-codes","text":"200 OK : The request was successful, and the prediction is returned. 400 Bad Request : The input data is invalid or missing. 500 Internal Server Error : An unexpected error occurred processing the request.","title":"Response Codes"},{"location":"User%20Docs/API/Endpoints/#response-body","text":"Content-Type : application/json Structure (on success): { \"predictedPrice\": 250000 }","title":"Response Body"},{"location":"User%20Docs/API/outline/","text":"(delete this line) use this for a starting outline for your docs Name/Title Overview else","title":"Outline"},{"location":"User%20Docs/API/outline/#nametitle","text":"","title":"Name/Title"},{"location":"User%20Docs/API/outline/#overview","text":"","title":"Overview"},{"location":"User%20Docs/API/outline/#else","text":"","title":"else"},{"location":"User%20Docs/Web%20Interface/outline/","text":"(delete this line) use this for a starting outline for your docs Name/Title Overview else","title":"Outline"},{"location":"User%20Docs/Web%20Interface/outline/#nametitle","text":"","title":"Name/Title"},{"location":"User%20Docs/Web%20Interface/outline/#overview","text":"","title":"Overview"},{"location":"User%20Docs/Web%20Interface/outline/#else","text":"","title":"else"}]}